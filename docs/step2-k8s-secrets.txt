Before we begin, Please read a small intro on need for secrets management. Document name "secret_need.txt"


===============================================================================
STEP 2 – SECRET MANAGEMENT FOR MYSQL + BACKEND IN KUBERNETES
===============================================================================
Goal of this step:
- Remove plain-text passwords from the Deployment YAMLs.
- Store DB passwords in Kubernetes Secrets.
- Re-deploy MySQL + backend using the Secret.
- Confirm that the app still works exactly as in Step 1.

Assumptions:
- You have already completed **Step 1** and everything works in namespace `sample-app`.
- You are using **StatefulSet** for MySQL (not Deployment) - this is what you set up in Step 1.
- You have separate files: `mysql-statefulset.yaml` and `mysql-service.yaml`.
- You are running these commands from one Alma node (e.g. `alma-one`).
- Your project folder is on that node, for example:

  /home/youruser/sample-react-project

  and you are inside it:

  cd /home/youruser/sample-react-project

IMPORTANT NOTE:
- Your current MySQL StatefulSet probably has plain-text passwords in the YAML.
- We will replace it with the new `k8s/mysql-statefulset.yaml` that uses Secrets.
- The existing PVC (from volumeClaimTemplates) will remain - no data loss.

-------------------------------------------------------------------------------
0. Quick theory – ConfigMap vs Secret
-------------------------------------------------------------------------------
- **ConfigMap**:
  - For NON-sensitive config (host names, feature flags, etc.).
  - Data is plain text.
- **Secret**:
  - For sensitive values (passwords, tokens, keys).
  - Stored base64-encoded; can be encrypted at rest by the cluster.

In Step 2 we only care about:
- MySQL root password
- App DB user + password

These all belong in a **Secret**, not hard-coded in YAML.

-------------------------------------------------------------------------------
1. Understanding your current setup (StatefulSet)
-------------------------------------------------------------------------------
In Step 1, you changed MySQL from Deployment to StatefulSet (which is better
for databases). Your working setup uses:
- `k8s/mysql-statefulset.yaml` (or similar) - StatefulSet with volumeClaimTemplates
- `k8s/mysql-service.yaml` - Separate Service file

For Step 2, we have prepared updated files that use Secrets:
- `k8s/mysql-statefulset.yaml` - StatefulSet that reads passwords from Secret
- `k8s/mysql-service.yaml` - Service (unchanged, no secrets needed)
- `k8s/backend-deployment.yaml` - Already updated to use Secret

These files reference:
- Secret name: `mysql-credentials`
- Namespace: `sample-app`


- Keys:
  - `mysql-root-password`
  - `db-user`
  - `db-password`

-------------------------------------------------------------------------------
2. Create the Secret manifest
-------------------------------------------------------------------------------
We added a manifest at `k8s/secrets.yaml`:

- Kind: `Secret`
- Name: `mysql-credentials`
- Namespace: `sample-app`
- Uses `stringData` (so you can write human-readable values; Kubernetes will
  convert to base64 on its own).

You can open this file and read it:

  cat k8s/secrets.yaml

It should look like:
- `mysql-root-password: rootpassword`
- `db-user: appuser`
- `db-password: apppassword`

You may change these passwords later if you want, but for now we keep them
matching Step 1 so the app continues to work.

-------------------------------------------------------------------------------
3. Apply the Secret into the cluster
-------------------------------------------------------------------------------
From the project root:

  kubectl apply -f k8s/secrets.yaml

What this does:
- Creates (or updates) the Secret `mysql-credentials` in namespace `sample-app`.

Check:

  kubectl get secrets -n sample-app

You should see a line similar to:

  mysql-credentials   Opaque    3      ...

To inspect (just to verify keys exist) WITHOUT showing values:

  kubectl describe secret mysql-credentials -n sample-app

It should list keys:
- `db-password`
- `db-user`
- `mysql-root-password`

-------------------------------------------------------------------------------
4. Re-apply MySQL StatefulSet and backend deployment
-------------------------------------------------------------------------------
Now that the Secret exists, we tell Kubernetes to refresh the StatefulSet
and Deployment so they use it.

IMPORTANT: Since you're using StatefulSet for MySQL, we need to be careful.
StatefulSets manage persistent storage, so we'll update it properly.

4.1 Apply the updated MySQL StatefulSet (with secrets)

  kubectl apply -f k8s/mysql-statefulset.yaml

This will:
- Update the StatefulSet so env vars come from `mysql-credentials`.
- Keep the volumeClaimTemplates the same (your existing PVC will remain).

4.2 Apply the MySQL Service (if not already applied)

  kubectl apply -f k8s/mysql-service.yaml

This is just the Service - no secrets here, just making sure it exists.

4.3 Re-apply backend

  kubectl apply -f k8s/backend-deployment.yaml

This will:
- Keep Service and other settings the same.
- Update env vars for `DB_USER` and `DB_PASSWORD` to use the Secret.

-------------------------------------------------------------------------------
5. Restart pods to pick up the new Secret
-------------------------------------------------------------------------------
`kubectl apply` might update pods automatically, but it is good practice
to explicitly roll them out so you clearly see the change.

5.1 Restart MySQL StatefulSet

  kubectl rollout restart statefulset/mysql -n sample-app

Note: For StatefulSet, we use `statefulset/mysql` instead of `deploy/mysql`.

5.2 Restart backend deployment

  kubectl rollout restart deploy/backend -n sample-app

Now watch pods:

  kubectl get pods -n sample-app

You should see:
- Old pods terminating
- New pods starting
- Eventually:
  - 1 `mysql-0` pod `Running` (StatefulSet pods have numbered names like mysql-0)
  - 2 `backend-...` pods `Running`
  - 2 `frontend-...` pods `Running` (frontend didn't change in this step)

If any pod is not `Running`, check:

  kubectl describe pod <pod-name> -n sample-app
  kubectl logs <pod-name> -n sample-app

-------------------------------------------------------------------------------
6. Verify the app still works
-------------------------------------------------------------------------------
Repeat the same test as in Step 1.

6.1 Port-forward frontend service

  kubectl port-forward -n sample-app svc/frontend 4000:80

6.2 Open the app (same as before)

  http://localhost:4000

Check:
- The UI loads.
- Existing users from MySQL are visible.
- You can add new users successfully.

If something is broken (e.g., "Failed to fetch users"):
- Check backend logs:

  kubectl logs <backend-pod-name> -n sample-app

Look specifically for:
- "ER_ACCESS_DENIED_ERROR" -> Secret username/password mismatch.
- "ENOTFOUND mysql" or similar -> DB_HOST issue (should still be `mysql`).

-------------------------------------------------------------------------------
7. How to change passwords later (optional)
-------------------------------------------------------------------------------
If you want to rotate DB passwords:

1. Update the Secret manifest file:

   - Edit `k8s/secrets.yaml` and change values under `stringData`, for example:
     - `db-password: NEWPASSWORD`
     - `mysql-root-password: NEWROOTPASSWORD`

2. Apply the Secret again:

   kubectl apply -f k8s/secrets.yaml

3. Make sure MySQL is using the same new credentials:
   - For full rotation, you’d also log into MySQL and change the actual user
     password there using SQL commands.

4. Restart StatefulSet and deployment:

   kubectl rollout restart statefulset/mysql -n sample-app
   kubectl rollout restart deploy/backend -n sample-app

-------------------------------------------------------------------------------
8. Checklist before moving to Step 3 (Argo CD)
-------------------------------------------------------------------------------
You are ready for Step 3 when:
- [ ] Secret `mysql-credentials` exists in namespace `sample-app`.
- [ ] MySQL StatefulSet reads its passwords from the Secret.
- [ ] Backend deployment reads its DB user/password from the Secret.
- [ ] All pods in `sample-app` are `Running`.
- [ ] The app still works exactly like Step 1 (list + add users).
- [ ] You understand at a high level:
      - Why we moved passwords into a Secret.
      - How env vars use `valueFrom.secretKeyRef`.

Once everything above is true, tell me, and I will prepare **Step 3 file**
to add Argo CD (GitOps) on top of this setup.

End of Step 2 document.


