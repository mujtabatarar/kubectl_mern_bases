===============================================================================
STEP 2 – SECRET MANAGEMENT FOR MYSQL + BACKEND IN KUBERNETES
===============================================================================
Goal of this step:
- Remove plain-text passwords from the Deployment YAMLs.
- Store DB passwords in Kubernetes Secrets.
- Re-deploy MySQL + backend using the Secret.
- Confirm that the app still works exactly as in Step 1.

Assumptions:
- You have already completed **Step 1** and everything works in namespace `sample-app`.
- You are running these commands from one Alma node (e.g. `alma-one`).
- Your project folder is on that node, for example:

  /home/youruser/sample-react-project

  and you are inside it:

  cd /home/youruser/sample-react-project

-------------------------------------------------------------------------------
0. Quick theory – ConfigMap vs Secret
-------------------------------------------------------------------------------
- **ConfigMap**:
  - For NON-sensitive config (host names, feature flags, etc.).
  - Data is plain text.
- **Secret**:
  - For sensitive values (passwords, tokens, keys).
  - Stored base64-encoded; can be encrypted at rest by the cluster.

In Step 2 we only care about:
- MySQL root password
- App DB user + password

These all belong in a **Secret**, not hard-coded in YAML.

-------------------------------------------------------------------------------
1. Look at current MySQL and backend env vars
-------------------------------------------------------------------------------
We already updated the YAML files so that:
- `k8s/mysql-deployment.yaml`:
  - `MYSQL_ROOT_PASSWORD`, `MYSQL_USER`, `MYSQL_PASSWORD` now come from a Secret.
- `k8s/backend-deployment.yaml`:
  - `DB_USER`, `DB_PASSWORD` now come from a Secret.

You do NOT need to change those files now; just know they already reference:
- Secret name: `mysql-credentials`
- Namespace: `sample-app`
- Keys:
  - `mysql-root-password`
  - `db-user`
  - `db-password`

-------------------------------------------------------------------------------
2. Create the Secret manifest
-------------------------------------------------------------------------------
We added a manifest at `k8s/secrets.yaml`:

- Kind: `Secret`
- Name: `mysql-credentials`
- Namespace: `sample-app`
- Uses `stringData` (so you can write human-readable values; Kubernetes will
  convert to base64 on its own).

You can open this file and read it:

  cat k8s/secrets.yaml

It should look like:
- `mysql-root-password: rootpassword`
- `db-user: appuser`
- `db-password: apppassword`

You may change these passwords later if you want, but for now we keep them
matching Step 1 so the app continues to work.

-------------------------------------------------------------------------------
3. Apply the Secret into the cluster
-------------------------------------------------------------------------------
From the project root:

  kubectl apply -f k8s/secrets.yaml

What this does:
- Creates (or updates) the Secret `mysql-credentials` in namespace `sample-app`.

Check:

  kubectl get secrets -n sample-app

You should see a line similar to:

  mysql-credentials   Opaque    3      ...

To inspect (just to verify keys exist) WITHOUT showing values:

  kubectl describe secret mysql-credentials -n sample-app

It should list keys:
- `db-password`
- `db-user`
- `mysql-root-password`

-------------------------------------------------------------------------------
4. Re-apply MySQL and backend deployments
-------------------------------------------------------------------------------
Now that the Secret exists, we tell Kubernetes to refresh the Deployments
so they use it. We do this with `kubectl apply` on the updated YAML files.

4.1 Re-apply MySQL

  kubectl apply -f k8s/mysql-deployment.yaml

This will:
- Keep the PVC and Service the same.
- Update the Deployment so the env vars come from `mysql-credentials`.

4.2 Re-apply backend

  kubectl apply -f k8s/backend-deployment.yaml

This will:
- Keep Service and other settings the same.
- Update env vars for `DB_USER` and `DB_PASSWORD` to use the Secret.

-------------------------------------------------------------------------------
5. Restart pods to pick up the new Secret
-------------------------------------------------------------------------------
`kubectl apply` might update pods automatically, but it is good practice
to explicitly roll them out so you clearly see the change.

5.1 Restart MySQL deployment

  kubectl rollout restart deploy/mysql -n sample-app

5.2 Restart backend deployment

  kubectl rollout restart deploy/backend -n sample-app

Now watch pods:

  kubectl get pods -n sample-app

You should see:
- Old pods terminating
- New pods starting
- Eventually:
  - 1 `mysql-...` pod `Running`
  - 2 `backend-...` pods `Running`
  - 2 `frontend-...` pods `Running` (frontend didn’t change in this step)

If any pod is not `Running`, check:

  kubectl describe pod <pod-name> -n sample-app
  kubectl logs <pod-name> -n sample-app

-------------------------------------------------------------------------------
6. Verify the app still works
-------------------------------------------------------------------------------
Repeat the same test as in Step 1.

6.1 Port-forward frontend service

  kubectl port-forward -n sample-app svc/frontend 4000:80

6.2 Open the app (same as before)

  http://localhost:4000

Check:
- The UI loads.
- Existing users from MySQL are visible.
- You can add new users successfully.

If something is broken (e.g., "Failed to fetch users"):
- Check backend logs:

  kubectl logs <backend-pod-name> -n sample-app

Look specifically for:
- "ER_ACCESS_DENIED_ERROR" -> Secret username/password mismatch.
- "ENOTFOUND mysql" or similar -> DB_HOST issue (should still be `mysql`).

-------------------------------------------------------------------------------
7. How to change passwords later (optional)
-------------------------------------------------------------------------------
If you want to rotate DB passwords:

1. Update the Secret manifest file:

   - Edit `k8s/secrets.yaml` and change values under `stringData`, for example:
     - `db-password: NEWPASSWORD`
     - `mysql-root-password: NEWROOTPASSWORD`

2. Apply the Secret again:

   kubectl apply -f k8s/secrets.yaml

3. Make sure MySQL is using the same new credentials:
   - For full rotation, you’d also log into MySQL and change the actual user
     password there using SQL commands.

4. Restart deployments:

   kubectl rollout restart deploy/mysql -n sample-app
   kubectl rollout restart deploy/backend -n sample-app

-------------------------------------------------------------------------------
8. Checklist before moving to Step 3 (Argo CD)
-------------------------------------------------------------------------------
You are ready for Step 3 when:
- [ ] Secret `mysql-credentials` exists in namespace `sample-app`.
- [ ] MySQL deployment reads its passwords from the Secret.
- [ ] Backend deployment reads its DB user/password from the Secret.
- [ ] All pods in `sample-app` are `Running`.
- [ ] The app still works exactly like Step 1 (list + add users).
- [ ] You understand at a high level:
      - Why we moved passwords into a Secret.
      - How env vars use `valueFrom.secretKeyRef`.

Once everything above is true, tell me, and I will prepare **Step 3 file**
to add Argo CD (GitOps) on top of this setup.

End of Step 2 document.


